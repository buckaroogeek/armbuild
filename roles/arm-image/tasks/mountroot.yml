---
- name: Initialise some variables
  set_fact:
    partflags: []
    lvm: ""
    
- name: "Checking for redirect and setting redcheck.stdout_lines.0 to notredirect or the actual url"
  shell: 'curl {{ fetch }} --max-time 5 --max-redirs 0 --silent > /dev/null && curl {{ fetch }} --max-redirs 0 --silent |grep moved|cut -d\" -f2 || echo notredirect'
  args:
    warn: no
  register: redcheck

- debug: var=redcheck.stdout_lines.0

- name: "Use the redirect URL {{ redcheck.stdout_lines.0 }} to avoid redownloading large images"
  set_stats:
    data: 
      url: "{{ redcheck.stdout_lines.0 }}"
  when: redcheck.stdout_lines.0 != "notredirect"

- name: "Else use the original URL {{ fetch }}"
  set_stats:
    data: 
      url: "{{ fetch }}"
  when: redcheck.stdout_lines.0 == "notredirect"

- name: "Download the image from {{ url }}"
  get_url:
    url: "{{ url }}"
    dest: "{{ workpath }}/{{ url | basename }}"
  register: download
- debug: var=download

- set_fact:
    extractedfile: "{{ download.dest | regex_replace('.xz') | regex_replace('.zip', '.img') }}"

- name: "Check that {{ extractedfile }} exists"
  stat:
    path: "{{ extractedfile }}"
  register: raw_image_stat_result

- name: Extract xz archives
  command: "unxz -k {{ download.dest }}"
  when: ( raw_image_stat_result.stat.exists == False ) and ( url.find("xz") != -1 ) 

- debug: var=raw_image_stat_result
- debug: var=raw_image_stat_result.stat.exists
- debug: var=url
- fail:

- name: Extract zip archives
  unarchive:
    src: "{{ download.dest }}"
    dest: "{{ workpath }}"
    keep_newer: true
  when: url.find("zip") != -1

- name: "Stat {{ extractedfile }}"
  stat:
    path: "{{ extractedfile }}"
  register: raw_image_stat_result

- debug: var=raw_image_stat_result.stat

- name: Read device information (always use unit when probing)
  parted:
    device: "{{ extractedfile }}"
    unit: B
  register: raw_part

- debug: var=raw_part.partitions

- name: Concatenate partition flags to check if there are lvm ones
  set_fact:
    partflags: "{{ partflags + item.flags }}"
  loop: "{{ raw_part.partitions }}"

- name: Enable lvm handling if an lvm flag is found
  set_fact:
    lvm: true
  loop: "{{ partflags }}"
  when: item == "lvm"

- name: Select the main partition
  set_fact:
    main_partition:
      - "{{ raw_part.partitions|last }}"

- set_fact:
    remaining_parts: "{{ raw_part.partitions | difference( main_partition ) }}"

- set_fact:
    boot_partition: 
      - "{{ remaining_parts|last }}"

- name: make sure local mount stubs exist
  file:
    name: "{{ item }}"
    mode: '0700'
    state: directory
  loop:
    - "{{ rawmnt }}"
    - "{{ bootmnt }}"

- name: mount the main partition
  mount:
    src: "{{ extractedfile }}"
    path: "{{ rawmnt }}"
    opts: rw,loop,offset={{ main_partition.0.begin | int }}
    state: mounted
    fstab: /tmp/fstab.dummy
    fstype: "{{ main_partition.0.fstype | regex_replace('fat32', 'vfat')}}"
  when: lvm != true


- command: "kpartx -av {{ extractedfile }}"
  when: url.find("aarch64") != -1
  register: kpartx_output
- debug: var=kpartx_output
- name: mount the raw disk
  mount:
    src: "/dev/fedora/root"
    path: "{{ rawmnt }}"
    opts: rw
    state: mounted
    fstab: /tmp/fstab.dummy
    fstype: xfs
  when: lvm == true

- name: create a .ssh directory
  file:
    name: "{{ rawmnt }}/root/.ssh"
    mode: '0700'
    state: directory
- name: create a file
  file:
    path: "{{ rawmnt }}/root/.ssh/authorized_keys"
    mode: '0600'
    state: touch

- name: Set appropriate permissions on the authorized_keys file
  lineinfile:
    path: "{{ rawmnt }}/root/.ssh/authorized_keys"
    state: present
    line: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC/OzKiop0vzsvRJRadSHwj1nF2aKFGeCAreJJbBXkE0pW4Bo/MUgYr7zJia+7Z5x9COlS5gUMAyjg3EOR/XDZvoe0tkpcu1sTG2Ac5yOId91uoev0Vm3IKOttCEXjmgVRe7UYJfY0pAM+8S5MqDnylFpN1Uuoj7f5Ulkhx7HVEr7KWsXnLv/P09dEW+s9Ebpl9hnDFjzeRw9thIBRgXwzEmKdMxzgq+nVwUg3HfxEyf9jFSutfMNepmg7T7uQyQ2p38yy0nB+bmjzeRNHDzadNpTKJE2MYYzun9J6+8LAE8/HadvpWWIo5hEQJ519c8mYmqt4yso+uLJMAIBNOg9Z73IPVr8yuo6c6GY3jWI1cZB51OO1v+6dOM83tlN8w2vwIop2IoF1zc3OKolPXaP7NZttD8y+FOJrAnvSIooArEwenMEgJ8S03UMltMpDvNss/0+FLVx89WHs1mmr+8w8lAaO5LlN279RwiC+Lh13yP8oWmVUGGN0wGVsTWI494wk= root@a31.vebate.it"

- name: Set root password
  lineinfile:
    path: "{{ rawmnt }}/etc/shadow"
    state: present
    line: 'root:$6$J0i11mQkC3hUrO0G$u371fR0mPIS.bKQlIPFPXMbS7n62ZqJqamwv/WgsX9OeCznfHh97arNRl.TWUsc7.E7HqO50NTR.CbL/dp2Az0::0:99999:7:::'
    regexp: '^root:'

- name: Permit root login via ssh
  lineinfile:
    path: "{{ rawmnt }}/etc/ssh/sshd_config"
    state: present
    line: "PermitRootLogin yes"
    regexp: '^PermitRootLogin'

- name: Ensure existance a directory to store kernels exists
  file:
    path: "{{ kernelpath }}"
    state: directory
    mode: '0755'

- name: Enable & start the libvirtd service
  service:
    name: libvirtd
    state: started
    enabled: yes

- name: Copy over the modules from the new system to its kernelpath in our libvirt stash
  command: "cp -uvrfp {{ rawmnt }}/lib/modules {{ kernelpath }}/lib"

- name: Include os-specific steps
  include: "{{ item }}-rootpart.yml"
  when: url.find(item) != -1
  loop:
    - raspbian
    - fedora

- name: Unmount the root partition
  mount:
    path: "{{ rawmnt }}"
    state: unmounted

- name: mount the boot partition
  mount:
    src: "{{ extractedfile }}"
    path: "{{ bootmnt }}"
    opts: rw,loop,offset={{ boot_partition.0.begin | int }}
    state: mounted
    fstab: /tmp/fstab.dummy
    fstype: "{{ boot_partition.0.fstype | regex_replace('fat32', 'vfat') }}"
  when: lvm != true

- name: Include os-specific steps
  include: "{{ item }}-bootpart.yml"
  when: url.find(item) != -1
  loop:
    - raspbian
    - fedora

- name: Unmount the raw volumes
  mount:
    path: "{{ bootmnt }}"
    state: unmounted
